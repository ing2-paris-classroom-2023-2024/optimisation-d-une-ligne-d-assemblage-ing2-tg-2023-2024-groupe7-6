//
// Created by quent on 29/11/2023.
//

#include <stdlib.h>
#include "header.h"

#define MAX_NOEUDS 100
#define CHEMIN_FICHIER "PERT.txt"  // Chemin vers le fichier PERT.txt



Noeud* creerNoeud(int v) {
    Noeud* nouveauNoeud = malloc(sizeof(Noeud));
    nouveauNoeud->sommet = v;
    nouveauNoeud->suivant = NULL;
    return nouveauNoeud;
}

Graphe* creerGraphe(int sommets) {
    Graphe* graphe = malloc(sizeof(Graphe));
    graphe->nbSommets = sommets ;

    graphe->listesAdj = malloc((sommets) * sizeof(Noeud*));
    graphe->listesPred = malloc(sommets * sizeof(Noeud*));

    for (int i = 0; i < sommets; i++) {
        graphe->listesAdj[i] = NULL;
        graphe->listesPred[i] = NULL;
    }

    return graphe;
}

void ajouterArc(Graphe* graphe, int src, int dest) {
    Noeud* nouveauNoeud = creerNoeud(dest);
    nouveauNoeud->suivant = graphe->listesAdj[src];
    graphe->listesAdj[src] = nouveauNoeud;
}

void ajouterPredecesseur(Graphe* graphe, int sommet, int predecesseur) {
    Noeud* nouveauNoeud = creerNoeud(predecesseur);
    nouveauNoeud->suivant = graphe->listesPred[sommet];
    graphe->listesPred[sommet] = nouveauNoeud;
}

void chargerGrapheDepuisFichier(Graphe* graphe, char* nomFichier) {
    FILE *fichier = fopen(nomFichier, "r");
    if (fichier == NULL) {
        perror("erreur ouverture\n");
        return;
    }

    int src, dest;
    while (fscanf(fichier, "%d %d", &src, &dest) != EOF) {
        ajouterArc(graphe, src, dest);
        ajouterPredecesseur(graphe, dest, src);

    }

    fclose(fichier);
}

int compterArcs (Graphe* graphe){
    int nombreArcs = 0;
    for (int i = 0; i < graphe->nbSommets; i++) {
        Noeud* temp = graphe->listesAdj[i];
        while (temp != NULL) {
            nombreArcs++;
            temp = temp->suivant;
        }
    }
    return nombreArcs;
}
/*
void afficherGraphe(Graphe* graphe) {
    for (int v = 0; v < graphe->nbSommets; v++) {
        Noeud* temp = graphe->listesAdj[v];
        printf("Liste d'adjacence du sommet %d\n tete", v);
        while (temp) {
            printf(" -> %d", temp->sommet);
            temp = temp->suivant;
        }
        printf("\n");
    }
}
*/
void afficherPredecesseurs(Graphe* graphe) {

    for (int i = 1; i < graphe->nbSommets; i++) {
        printf("Predecesseurs du sommet %d: ", i);
        Noeud* temp = graphe->listesPred[i];
        if (temp == NULL) {
            printf("Aucun");
        }
        while (temp) {
            printf("%d ", temp->sommet);
            temp = temp->suivant;
        }
        printf("\n");
    }
}


int lireTachesDepuisFichier(const char* cheminFichier, Tache taches[]) {
    FILE* fichier = fopen(cheminFichier, "r");
    if (fichier == NULL) {
        perror("Erreur lors de l'ouverture du fichier");
        return -1;
    }

    int indice = 0;
    while (fscanf(fichier, "%d %d %lf", &taches[indice].debut, &taches[indice].fin, &taches[indice].duree) == 3) {
        indice++;
    }

    fclose(fichier);
    return indice;  // Retourne le nombre de tâches lues
}


void trouverCheminCritique(Tache taches[], int nbTaches) {
    double plusLongChemin[MAX_NOEUDS] = {0};
    int predecesseurs[MAX_NOEUDS] = {0};

    for (int i = 0; i < nbTaches; i++) {
        if (plusLongChemin[taches[i].fin] < plusLongChemin[taches[i].debut] + taches[i].duree) {
            plusLongChemin[taches[i].fin] = plusLongChemin[taches[i].debut] + taches[i].duree;
            predecesseurs[taches[i].fin] = taches[i].debut;
        }
    }

    // Trouver le dernier nœud
    double dureeMax = 0;
    int dernierNoeud = 0;
    for (int i = 0; i < MAX_NOEUDS; i++) {
        if (plusLongChemin[i] > dureeMax) {
            dureeMax = plusLongChemin[i];
            dernierNoeud = i;
        }
    }

    // Retracer le chemin critique
    printf("Chemin critique (en sens inverse) : ");
    while (dernierNoeud != 0) {
        printf("%d ", dernierNoeud);
        dernierNoeud = predecesseurs[dernierNoeud];
    }
    printf("\nDurée totale : %f\n", dureeMax);
}

